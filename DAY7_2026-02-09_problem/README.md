## ğŸ§© Detailed Problem Statement

You are working as a **Data Engineer / Analytics Engineer** for an infrastructure monitoring team.

Your system captures **CPU usage logs** generated by users across different days.  
Each log represents the **number of CPU minutes consumed by a user on a given date**.

The raw data is stored in the table `cpu_usage`.

---

### ğŸ“‹ What the Data Represents

- Each row corresponds to **CPU minutes consumed by a user on a specific date**
- A **single user can have multiple rows on the same day**
  - This happens due to:
    - multiple jobs
    - retries
    - partial executions
- CPU usage must therefore be **aggregated per user per day** before analysis

---

### ğŸ§  Business Requirement

The infrastructure team wants to identify **â€œheavy CPU consumersâ€** for each day.

However, instead of applying a fixed per-user threshold, the team follows the  
**Pareto Principle (80/20 rule)**:

> *A small number of users are usually responsible for the majority of resource consumption.*

---

### ğŸ¯ Objective (What You Must Find)

For **each `usage_date`**, identify:

> **The minimum number of users whose combined CPU usage contributes to at least 80% of the total CPU usage for that day.**

In simple terms:

- Sort users by **total CPU usage (highest first)**
- Start adding users one by one
- Stop **as soon as cumulative usage reaches or crosses 80%**
- Return **only those users**

---

### ğŸ“Œ Important Clarifications (VERY IMPORTANT)

#### 1ï¸âƒ£ Aggregate First (Mandatory)
If a user appears multiple times on the same day:
- You **must sum their CPU usage first**
- Treat them as **one user per day**
- Failure to do this results in **wrong ranking**

---

#### 2ï¸âƒ£ Ordering Logic
Users must be ordered by:
1. Total CPU usage (descending)
2. `user_id` (ascending) â€” **only for tie-breaking**

---

#### 3ï¸âƒ£ Minimum Set Rule
You must return the **smallest possible set of users** such that:


Once this condition is satisfied:
- âŒ Do NOT include additional users
- âŒ Do NOT aim for closest-to-80
- âœ… Stop immediately

---

#### 4ï¸âƒ£ Exact 80% Boundary
If cumulative usage becomes **exactly 80%**:
- That is considered **complete**
- Do **NOT** include the next user

---

#### 5ï¸âƒ£ Single-User Days
If a day contains:
- Only **one user**, or
- One user alone contributes **â‰¥ 80%**

Then:
- That single user must be returned

---

#### 6ï¸âƒ£ Zero CPU Usage Handling
- Users with `cpu_minutes = 0`:
  - Must not affect cumulative percentage
  - Must not incorrectly appear in the output
- Days where **total CPU usage = 0**:
  - Must be excluded completely
  - Prevent divide-by-zero errors

---

#### 7ï¸âƒ£ Precision Matters
- Percentages must be calculated accurately
- Rounding errors can cause:
  - Wrong user inclusion
  - Boundary violations
- Use decimal-based calculations (`* 100.0`)

---

### ğŸ“¤ Expected Output

For each `usage_date`, output:

| Column Name | Description |
|------------|------------|
| usage_date | The date of CPU usage |
| users | Comma-separated list of selected `user_id`s |

---

### ğŸ§ª Example Explanation (Conceptual)

If a day has the following aggregated usage:

| user_id | cpu_minutes |
|--------|-------------|
| 101 | 50 |
| 102 | 30 |
| 103 | 10 |
| 104 | 10 |

Total CPU = 100

Cumulative selection:
- 101 â†’ 50%
- 101,102 â†’ 80% âœ… stop

âœ” Output users: `101,102`

---

### ğŸ¤ Interview Explanation (1â€“2 Lines)

> â€œI aggregate CPU usage per user per day, rank users by consumption, compute cumulative percentages using window functions, and select the minimum set of users whose cumulative CPU usage reaches at least 80%, carefully handling edge cases like duplicates, zero usage, and exact threshold boundaries.â€

---

### ğŸ§  Why This Problem Is Hard

This problem tests:
- Correct **aggregation before ranking**
- Proper **window function usage**
- Careful **boundary condition handling**
- Real-world infra analytics thinking
- Avoiding subtle logical bugs

This is a **production-grade SQL analytics problem**, not a toy example.

---
